# ğŸ“‹ PLANO DE MIGRAÃ‡ÃƒO TDD - MÃ“DULO AUTOCONHECIMENTO

## ğŸ¯ CONTEXTO

MigraÃ§Ã£o do mÃ³dulo de autoconhecimento de uma arquitetura baseada em localStorage para uma arquitetura de dados dual, seguindo **metodologia TDD rigorosa** estabelecida na FASE 0:
- **ProduÃ§Ã£o**: Supabase (PostgreSQL com RLS)
- **Desenvolvimento/Testes**: Backend FastAPI local (SQLAlchemy + PostgreSQL local)
- **Metodologia**: Test-Driven Development (Red-Green-Refactor)
- **Infraestrutura**: Vitest + RTL + MSW + Quality Gates automÃ¡ticos

## ğŸ§ª PREPARAÃ‡ÃƒO TDD - INFRAESTRUTURA PRONTA

### âœ… Ferramentas Configuradas (FASE 0)
- **Vitest** - Test runner com coverage V8 (target: 70%+)
- **React Testing Library** - Testes user-centric
- **MSW** - Mock Service Worker para APIs
- **GitHub Actions** - Pipeline CI/CD com 7 quality gates
- **Factories & Utilities** - GeraÃ§Ã£o de dados e helpers

### ğŸ¯ Quality Gates AutomÃ¡ticos
| MÃ©trica | MÃ­nimo | Ideal |
|---------|--------|-------|
| Coverage Lines | 70% | 85% |
| Coverage Functions | 70% | 85% |
| Test Performance | < 100ms | < 50ms |
| Suite Completa | < 30s | < 15s |

---

## ğŸ” 1. RELATÃ“RIO DE AUDITORIA DO LOCALSTORAGE + TESTES

### InventÃ¡rio de Chaves e Dados Armazenados

**Chave: `autoconhecimento-storage`**
- **Dados**: Sistema de notas de autoconhecimento com seÃ§Ãµes, tags e modo refÃºgio
- **Estrutura**:
  ```json
  {
    "state": {
      "notas": [
        {
          "id": "string",
          "titulo": "string",
          "conteudo": "string",
          "secao": "quem-sou" | "meus-porques" | "meus-padroes",
          "tags": ["string"],
          "dataCriacao": "ISO-8601",
          "dataAtualizacao": "ISO-8601",
          "imagemUrl": "string" // opcional
        }
      ],
      "modoRefugio": "boolean"
    },
    "version": 0
  }
  ```

### ğŸ§ª Factories TDD para Dados Existentes

```typescript
// __tests__/factories/autoconhecimento.ts
export const createNota = (overrides = {}) => ({
  id: `nota-${counter++}`,
  titulo: 'ReflexÃ£o sobre mim',
  conteudo: 'ConteÃºdo da nota de autoconhecimento...',
  secao: 'quem-sou',
  tags: ['reflexÃ£o', 'crescimento'],
  dataCriacao: '2025-01-20T10:00:00.000Z',
  dataAtualizacao: '2025-01-20T10:00:00.000Z',
  imagemUrl: null,
  ...overrides
})

export const createModoRefugio = (overrides = {}) => ({
  modoRefugio: false,
  ...overrides
})

export const createAutoconhecimentoState = (overrides = {}) => ({
  notas: createList(createNota, 3),
  modoRefugio: false,
  ...overrides
})
```

### Componentes Dependentes + EstratÃ©gia de Testes

| Componente | Responsabilidade | EstratÃ©gia TDD |
|------------|------------------|----------------|
| **EditorNotas.tsx** | Editor WYSIWYG com tags e imagens | âœ… Testes de FormulÃ¡rio + ValidaÃ§Ã£o |
| **ListaNotas.tsx** | Lista filtrada por seÃ§Ã£o com busca | âœ… Testes de Busca + Filtros |
| **ModoRefugio.tsx** | Toggle de interface simplificada | âœ… Testes de Estado + UI |
| **AutoconhecimentoPage.tsx** | OrquestraÃ§Ã£o geral do mÃ³dulo | âœ… Testes de IntegraÃ§Ã£o |

### ğŸ¯ Cobertura de Testes Planejada

```typescript
// Estrutura de testes para o mÃ³dulo
__tests__/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ EditorNotas.test.tsx           # FormulÃ¡rio + ValidaÃ§Ã£o
â”‚   â”œâ”€â”€ ListaNotas.test.tsx            # Busca + Filtros
â”‚   â”œâ”€â”€ ModoRefugio.test.tsx           # Estado + UI
â”‚   â””â”€â”€ AutoconhecimentoPage.test.tsx  # IntegraÃ§Ã£o
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAutoconhecimento.test.ts    # Store + Mutations
â”‚   â”œâ”€â”€ useNotasSearch.test.ts         # Busca avanÃ§ada
â”‚   â””â”€â”€ useModoRefugio.test.ts         # Modo refÃºgio
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ autoconhecimentoApi.test.ts    # API calls
â”‚   â””â”€â”€ imageUploadService.test.ts     # Upload de imagens
â””â”€â”€ integration/
    â””â”€â”€ autoconhecimento-flow.test.tsx # E2E scenarios
```

---

## ğŸ—„ï¸ 2. ESQUEMA DE BANCO DE DADOS UNIFICADO (SQL)

```sql
-- Tabela de usuÃ¡rios (base para todo o sistema)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabela de notas de autoconhecimento
CREATE TABLE self_knowledge_notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    section VARCHAR(20) NOT NULL CHECK (section IN ('quem-sou', 'meus-porques', 'meus-padroes')),
    image_url VARCHAR(1000),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabela de tags para notas
CREATE TABLE self_knowledge_note_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    note_id UUID NOT NULL REFERENCES self_knowledge_notes(id) ON DELETE CASCADE,
    tag VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(note_id, tag)
);

-- Tabela de preferÃªncias do usuÃ¡rio
CREATE TABLE user_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    module VARCHAR(50) NOT NULL,
    preference_key VARCHAR(100) NOT NULL,
    preference_value JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, module, preference_key)
);

-- Ãndices para performance
CREATE INDEX idx_self_knowledge_notes_user_id ON self_knowledge_notes(user_id);
CREATE INDEX idx_self_knowledge_notes_section ON self_knowledge_notes(user_id, section);
CREATE INDEX idx_self_knowledge_notes_title ON self_knowledge_notes USING gin(to_tsvector('portuguese', title));
CREATE INDEX idx_self_knowledge_notes_content ON self_knowledge_notes USING gin(to_tsvector('portuguese', content));
CREATE INDEX idx_self_knowledge_note_tags_note_id ON self_knowledge_note_tags(note_id);
CREATE INDEX idx_self_knowledge_note_tags_tag ON self_knowledge_note_tags(tag);
CREATE INDEX idx_user_preferences_lookup ON user_preferences(user_id, module, preference_key);
```

---

## ğŸŒ 3. CONTRATO DE API (OpenAPI/Swagger Simplificado)

### AutenticaÃ§Ã£o
```markdown
POST /auth/login
- Payload Request: { "email": "string", "password": "string" }
- Payload Response: { "token": "string", "user": { "id": "uuid", "name": "string", "email": "string" } }
- Status Codes: 200 (Success), 401 (Unauthorized), 400 (Bad Request)

GET /auth/me
- Headers: Authorization: Bearer {token}
- Payload Response: { "id": "uuid", "name": "string", "email": "string" }
- Status Codes: 200 (Success), 401 (Unauthorized)
```

### Notas de Autoconhecimento
```markdown
GET /api/self-knowledge/notes
- Headers: Authorization: Bearer {token}
- Query Params: ?section=quem-sou&search=termo&limit=50&offset=0
- Payload Response: [{ "id": "uuid", "title": "ReflexÃ£o", "content": "...", "section": "quem-sou", "tags": ["crescimento"], "imageUrl": "https://...", "createdAt": "2025-01-20T10:00:00Z" }]
- Status Codes: 200 (Success), 401 (Unauthorized)

POST /api/self-knowledge/notes
- Headers: Authorization: Bearer {token}
- Payload Request: { "title": "Nova reflexÃ£o", "content": "ConteÃºdo...", "section": "meus-porques", "tags": ["valores"], "imageUrl": "data:image/..." }
- Payload Response: { "id": "uuid", "title": "Nova reflexÃ£o", "content": "ConteÃºdo...", "section": "meus-porques", "tags": ["valores"], "imageUrl": "https://..." }
- Status Codes: 201 (Created), 400 (Bad Request), 401 (Unauthorized)

PUT /api/self-knowledge/notes/{id}
- Headers: Authorization: Bearer {token}
- Payload Request: { "title": "TÃ­tulo atualizado", "content": "ConteÃºdo atualizado...", "tags": ["nova-tag"] }
- Payload Response: { "id": "uuid", "title": "TÃ­tulo atualizado", "content": "ConteÃºdo atualizado...", "section": "quem-sou", "tags": ["nova-tag"] }
- Status Codes: 200 (Success), 404 (Not Found), 401 (Unauthorized)

DELETE /api/self-knowledge/notes/{id}
- Headers: Authorization: Bearer {token}
- Status Codes: 204 (No Content), 404 (Not Found), 401 (Unauthorized)
```

### PreferÃªncias do UsuÃ¡rio
```markdown
GET /api/user/preferences/self-knowledge
- Headers: Authorization: Bearer {token}
- Payload Response: { "refugeMode": false, "showDates": true, "cardsPerPage": 10 }
- Status Codes: 200 (Success), 401 (Unauthorized)

PUT /api/user/preferences/self-knowledge
- Headers: Authorization: Bearer {token}
- Payload Request: { "refugeMode": true, "showDates": false }
- Payload Response: { "refugeMode": true, "showDates": false, "cardsPerPage": 10 }
- Status Codes: 200 (Success), 400 (Invalid Data), 401 (Unauthorized)
```

### Upload de Imagens
```markdown
POST /api/upload/image
- Headers: Authorization: Bearer {token}, Content-Type: multipart/form-data
- Payload Request: FormData com arquivo de imagem
- Payload Response: { "url": "https://storage.supabase.co/...", "filename": "image.jpg" }
- Status Codes: 201 (Created), 400 (Invalid File), 401 (Unauthorized), 413 (File Too Large)
```

---

## ğŸ“‹ 4. PLANO DE MIGRAÃ‡ÃƒO TDD DUAL-TRACK (MÃ‰TODO MOSCOW)

### **MUST HAVE (CrÃ­tico + TDD Rigoroso)**

#### ğŸ”´ RED â†’ ğŸŸ¢ GREEN â†’ ğŸ”µ REFACTOR

1. **[TDD Backend]** Testes de autenticaÃ§Ã£o JWT â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
2. **[TDD Backend]** Testes APIs self-knowledge/notes â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
3. **[TDD Frontend]** Testes service layer â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
4. **[TDD Frontend]** Testes fallback localStorage â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
5. **[TDD Database]** Testes schema + migrations â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o

**Quality Gate**: âœ… Coverage > 70% + Todos os testes passando antes de prosseguir

### **SHOULD HAVE (TDD + ExperiÃªncia Completa)**

6. **[TDD Backend]** Testes APIs upload imagens â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
7. **[TDD Frontend]** Testes migraÃ§Ã£o stores â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
8. **[TDD Frontend]** Testes sync offline/online â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
9. **[TDD Database]** Testes RLS Supabase â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
10. **[TDD Migration]** Testes script migraÃ§Ã£o â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o

**Quality Gate**: âœ… Coverage > 75% + Performance < 100ms + Zero bugs crÃ­ticos

### **COULD HAVE (TDD + OtimizaÃ§Ã£o)**

11. **[TDD Backend]** Testes busca full-text â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
12. **[TDD Frontend]** Testes optimistic updates â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
13. **[TDD Frontend]** Testes backup/restore â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
14. **[TDD Monitoring]** Testes logs/mÃ©tricas â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o
15. **[TDD Performance]** Testes paginaÃ§Ã£o/lazy â†’ ImplementaÃ§Ã£o â†’ RefatoraÃ§Ã£o

**Quality Gate**: âœ… Coverage > 80% + Performance < 50ms + MÃ©tricas de qualidade

### **WON'T HAVE (NÃ£o implementar nesta iteraÃ§Ã£o)**

16. **[Features]** IntegraÃ§Ã£o com IA para anÃ¡lise de padrÃµes
17. **[Features]** Sistema de comentÃ¡rios em notas
18. **[Infrastructure]** Deploy automatizado com CI/CD (jÃ¡ configurado na FASE 0)
19. **[Features]** NotificaÃ§Ãµes push para lembretes
20. **[Features]** Versionamento de notas com histÃ³rico

---

## ğŸ”§ CHECKLIST DE IMPLEMENTAÃ‡ÃƒO TDD

### **Fase 1: PreparaÃ§Ã£o TDD (Must Have)**
- [ ] ğŸ”´ Escrever testes de autenticaÃ§Ã£o JWT â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Escrever testes RLS Supabase â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Escrever testes schema BD â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Escrever testes service layer â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Escrever testes env config â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] âœ… **Quality Gate**: Coverage > 70% + Todos os testes passando

### **Fase 2: APIs Core TDD (Must Have + Should Have)**
- [ ] ğŸ”´ Testes CRUD self-knowledge notes â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes sistema de tags â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes busca e filtros â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes upload imagens â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes preferÃªncias usuÃ¡rio â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] âœ… **Quality Gate**: Coverage > 75% + Performance < 100ms

### **Fase 3: MigraÃ§Ã£o Frontend TDD (Should Have)**
- [ ] ğŸ”´ Testes EditorNotas â†’ ğŸŸ¢ Migrar APIs â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes ListaNotas â†’ ğŸŸ¢ Migrar APIs â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes ModoRefugio â†’ ğŸŸ¢ Migrar APIs â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes AutoconhecimentoPage â†’ ğŸŸ¢ Migrar APIs â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes sincronizaÃ§Ã£o â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] âœ… **Quality Gate**: Coverage > 80% + Zero bugs crÃ­ticos

### **Fase 4: Script MigraÃ§Ã£o TDD (Should Have)**
- [ ] ğŸ”´ Testes export localStorage â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes import BD â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes migraÃ§Ã£o real â†’ ğŸŸ¢ Executar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes rollback â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] âœ… **Quality Gate**: 100% dados migrados + Zero perda

### **Fase 5: OtimizaÃ§Ãµes TDD (Could Have)**
- [ ] ğŸ”´ Testes cache frontend â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes otimizaÃ§Ã£o queries â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes compressÃ£o imagens â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] ğŸ”´ Testes logs/mÃ©tricas â†’ ğŸŸ¢ Implementar â†’ ğŸ”µ Refatorar
- [ ] âœ… **Quality Gate**: Coverage > 85% + Performance < 50ms

---

## ğŸ§ª TEMPLATES DE TESTE ESPECÃFICOS DO MÃ“DULO

### Template: Componente EditorNotas

```typescript
// __tests__/components/EditorNotas.test.tsx
import { render, screen, userEvent } from '@/test-utils'
import { EditorNotas } from '@/components/autoconhecimento/EditorNotas'
import { createNota, createList } from '@/factories/autoconhecimento'

describe('EditorNotas', () => {
  const defaultProps = {
    id: undefined,
    secaoAtual: 'quem-sou' as const,
    onSave: vi.fn(),
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('ğŸ”´ RED: RenderizaÃ§Ã£o', () => {
    it('deve renderizar formulÃ¡rio de nova nota', () => {
      render(<EditorNotas {...defaultProps} />)

      expect(screen.getByLabelText(/tÃ­tulo/i)).toBeInTheDocument()
      expect(screen.getByLabelText(/conteÃºdo/i)).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /salvar/i })).toBeInTheDocument()
    })

    it('deve renderizar formulÃ¡rio de ediÃ§Ã£o quando id fornecido', () => {
      const nota = createNota({ titulo: 'Nota existente' })
      render(<EditorNotas {...defaultProps} id={nota.id} />)

      expect(screen.getByDisplayValue('Nota existente')).toBeInTheDocument()
    })
  })

  describe('ğŸŸ¢ GREEN: InteraÃ§Ãµes', () => {
    it('deve criar nova nota quando formulÃ¡rio Ã© submetido', async () => {
      const user = userEvent.setup()
      const onSave = vi.fn()
      render(<EditorNotas {...defaultProps} onSave={onSave} />)

      await user.type(screen.getByLabelText(/tÃ­tulo/i), 'Nova reflexÃ£o')
      await user.type(screen.getByLabelText(/conteÃºdo/i), 'ConteÃºdo da reflexÃ£o')
      await user.click(screen.getByRole('button', { name: /salvar/i }))

      expect(onSave).toHaveBeenCalledTimes(1)
    })

    it('deve adicionar tags quando usuÃ¡rio digita e pressiona Enter', async () => {
      const user = userEvent.setup()
      render(<EditorNotas {...defaultProps} />)

      const tagInput = screen.getByLabelText(/nova tag/i)
      await user.type(tagInput, 'crescimento{enter}')

      expect(screen.getByText('crescimento')).toBeInTheDocument()
    })
  })

  describe('ğŸ”µ REFACTOR: Estados e ValidaÃ§Ã£o', () => {
    it('deve validar campos obrigatÃ³rios', async () => {
      const user = userEvent.setup()
      render(<EditorNotas {...defaultProps} />)

      await user.click(screen.getByRole('button', { name: /salvar/i }))

      expect(screen.getByText(/tÃ­tulo Ã© obrigatÃ³rio/i)).toBeInTheDocument()
      expect(screen.getByText(/conteÃºdo Ã© obrigatÃ³rio/i)).toBeInTheDocument()
    })

    it('deve mostrar interface simplificada no modo refÃºgio', () => {
      // Mock do store com modo refÃºgio ativado
      vi.mocked(useAutoconhecimentoStore).mockReturnValue({
        modoRefugio: true,
        // ... outros valores
      })

      render(<EditorNotas {...defaultProps} />)

      expect(screen.getByText(/modo refÃºgio ativado/i)).toBeInTheDocument()
    })
  })
})
```

### Template: Hook useAutoconhecimento

```typescript
// __tests__/hooks/useAutoconhecimento.test.ts
import { renderHook, act } from '@testing-library/react'
import { useAutoconhecimento } from '@/hooks/useAutoconhecimento'
import { createQueryWrapper } from '@/test-utils'
import { server } from '@/mocks/server'
import { http, HttpResponse } from 'msw'

describe('useAutoconhecimento', () => {
  describe('ğŸ”´ RED: Estado Inicial', () => {
    it('deve retornar estado inicial correto', () => {
      const { result } = renderHook(() => useAutoconhecimento(), {
        wrapper: createQueryWrapper()
      })

      expect(result.current.notas).toEqual([])
      expect(result.current.isLoading).toBe(true)
      expect(result.current.error).toBe(null)
    })
  })

  describe('ğŸŸ¢ GREEN: OperaÃ§Ãµes CRUD', () => {
    it('deve adicionar nota com sucesso', async () => {
      const newNota = createNota({ titulo: 'Nova reflexÃ£o', secao: 'quem-sou' })

      server.use(
        http.post('/api/self-knowledge/notes', () => {
          return HttpResponse.json(newNota)
        })
      )

      const { result } = renderHook(() => useAutoconhecimento(), {
        wrapper: createQueryWrapper()
      })

      await act(async () => {
        await result.current.addNota(newNota)
      })

      expect(result.current.notas).toContainEqual(newNota)
    })
  })

  describe('ğŸ”µ REFACTOR: Error Handling', () => {
    it('deve lidar com erros de API', async () => {
      server.use(
        http.post('/api/self-knowledge/notes', () => {
          return HttpResponse.error()
        })
      )

      const { result } = renderHook(() => useAutoconhecimento(), {
        wrapper: createQueryWrapper()
      })

      await act(async () => {
        try {
          await result.current.addNota(createNota())
        } catch (error) {
          expect(error).toBeDefined()
        }
      })

      expect(result.current.error).toBeDefined()
    })
  })
})
```

### Template: ServiÃ§o AutoconhecimentoAPI

```typescript
// __tests__/services/autoconhecimentoApi.test.ts
import { vi } from 'vitest'
import { autoconhecimentoApi } from '@/services/autoconhecimentoApi'
import { server } from '@/mocks/server'
import { http, HttpResponse } from 'msw'
import { createNota, createList } from '@/factories/autoconhecimento'

describe('AutoconhecimentoAPI', () => {
  describe('ğŸ”´ RED: Self Knowledge Notes API', () => {
    it('deve buscar notas do usuÃ¡rio', async () => {
      const mockNotas = createList(createNota, 3)

      server.use(
        http.get('/api/self-knowledge/notes', () => HttpResponse.json(mockNotas))
      )

      const result = await autoconhecimentoApi.getNotas()
      expect(result).toEqual(mockNotas)
    })

    it('deve filtrar notas por seÃ§Ã£o', async () => {
      const notasQuemSou = createList(createNota, 2, [
        { secao: 'quem-sou' },
        { secao: 'quem-sou' }
      ])

      server.use(
        http.get('/api/self-knowledge/notes', ({ request }) => {
          const url = new URL(request.url)
          const section = url.searchParams.get('section')

          if (section === 'quem-sou') {
            return HttpResponse.json(notasQuemSou)
          }
          return HttpResponse.json([])
        })
      )

      const result = await autoconhecimentoApi.getNotas({ section: 'quem-sou' })
      expect(result).toEqual(notasQuemSou)
      expect(result.every(n => n.secao === 'quem-sou')).toBe(true)
    })
  })

  describe('ğŸŸ¢ GREEN: Error Handling', () => {
    it('deve lidar com erro 500 da API', async () => {
      server.use(
        http.get('/api/self-knowledge/notes', () => HttpResponse.error())
      )

      await expect(autoconhecimentoApi.getNotas()).rejects.toThrow()
    })
  })

  describe('ğŸ”µ REFACTOR: Optimistic Updates', () => {
    it('deve implementar optimistic updates para notas', async () => {
      const newNota = createNota()

      server.use(
        http.post('/api/self-knowledge/notes', () => HttpResponse.json(newNota))
      )

      const result = await autoconhecimentoApi.createNota(newNota)
      expect(result.id).toBeDefined()
      expect(result.titulo).toBe(newNota.titulo)
    })
  })
})
```

### Template: IntegraÃ§Ã£o E2E

```typescript
// __tests__/integration/autoconhecimento-flow.test.tsx
import { render, screen, userEvent } from '@/test-utils'
import { AutoconhecimentoPage } from '@/app/autoconhecimento/page'
import { server } from '@/mocks/server'
import { http, HttpResponse } from 'msw'

describe('Autoconhecimento E2E Flow', () => {
  describe('ğŸ”´ RED: Fluxo Completo', () => {
    it('deve permitir criar â†’ editar â†’ buscar â†’ deletar nota', async () => {
      const user = userEvent.setup()

      // Setup API mocks
      server.use(
        http.get('/api/self-knowledge/notes', () => HttpResponse.json([])),
        http.post('/api/self-knowledge/notes', () => HttpResponse.json({ id: '1' })),
        http.put('/api/self-knowledge/notes/1', () => HttpResponse.json({ id: '1' })),
        http.delete('/api/self-knowledge/notes/1', () => new HttpResponse(null, { status: 204 }))
      )

      render(<AutoconhecimentoPage />)

      // 1. Criar nova nota
      await user.click(screen.getByRole('button', { name: /nova nota/i }))
      await user.type(screen.getByLabelText(/tÃ­tulo/i), 'Minha reflexÃ£o')
      await user.type(screen.getByLabelText(/conteÃºdo/i), 'ConteÃºdo da reflexÃ£o')
      await user.click(screen.getByRole('button', { name: /salvar/i }))

      // 2. Editar nota
      await user.click(screen.getByRole('button', { name: /editar/i }))
      await user.clear(screen.getByLabelText(/tÃ­tulo/i))
      await user.type(screen.getByLabelText(/tÃ­tulo/i), 'ReflexÃ£o editada')
      await user.click(screen.getByRole('button', { name: /salvar/i }))

      // 3. Buscar nota
      await user.type(screen.getByLabelText(/buscar/i), 'reflexÃ£o')
      expect(screen.getByText(/reflexÃ£o editada/i)).toBeInTheDocument()

      // 4. Ativar modo refÃºgio
      await user.click(screen.getByRole('button', { name: /modo refÃºgio/i }))
      expect(screen.getByText(/modo refÃºgio ativado/i)).toBeInTheDocument()
    })
  })
})
```

---

## ğŸš€ CONSIDERAÃ‡Ã•ES TÃ‰CNICAS TDD

### Arquitetura do Service Layer
```typescript
// Exemplo de service abstrato para dual-track
interface IAutoconhecimentoService {
  getNotas: (filters?) => Promise<Nota[]>
  createNota: (data: CreateNotaDto) => Promise<Nota>
  updateNota: (id: string, data: UpdateNotaDto) => Promise<Nota>
  deleteNota: (id: string) => Promise<void>
  updatePreferences: (prefs: UserPreferences) => Promise<UserPreferences>
}

// ImplementaÃ§Ã£o para FastAPI
class FastAPIAutoconhecimentoService implements IAutoconhecimentoService {
  // implementaÃ§Ã£o especÃ­fica
}

// ImplementaÃ§Ã£o para Supabase
class SupabaseAutoconhecimentoService implements IAutoconhecimentoService {
  // implementaÃ§Ã£o especÃ­fica
}
```

### MSW Handlers EspecÃ­ficos do MÃ³dulo

```typescript
// __tests__/mocks/handlers/autoconhecimento.ts
import { http, HttpResponse } from 'msw'
import { createNota, createList, createModoRefugio } from '@/factories/autoconhecimento'

export const autoconhecimentoHandlers = [
  // Self Knowledge Notes
  http.get('/api/self-knowledge/notes', ({ request }) => {
    const url = new URL(request.url)
    const section = url.searchParams.get('section')
    const search = url.searchParams.get('search')

    let notas = createList(createNota, 5)

    if (section) {
      notas = notas.filter(nota => nota.secao === section)
    }

    if (search) {
      notas = notas.filter(nota =>
        nota.titulo.toLowerCase().includes(search.toLowerCase()) ||
        nota.conteudo.toLowerCase().includes(search.toLowerCase())
      )
    }

    return HttpResponse.json(notas)
  }),

  http.post('/api/self-knowledge/notes', async ({ request }) => {
    const newNota = await request.json()
    return HttpResponse.json(createNota(newNota), { status: 201 })
  }),

  http.put('/api/self-knowledge/notes/:id', async ({ request, params }) => {
    const updates = await request.json()
    return HttpResponse.json(createNota({ id: params.id, ...updates }))
  }),

  http.delete('/api/self-knowledge/notes/:id', () => {
    return new HttpResponse(null, { status: 204 })
  }),

  // User Preferences
  http.get('/api/user/preferences/self-knowledge', () => {
    return HttpResponse.json(createModoRefugio())
  }),

  http.put('/api/user/preferences/self-knowledge', async ({ request }) => {
    const preferences = await request.json()
    return HttpResponse.json(createModoRefugio(preferences))
  }),

  // Image Upload
  http.post('/api/upload/image', () => {
    return HttpResponse.json({
      url: 'https://storage.supabase.co/bucket/image.jpg',
      filename: 'image.jpg'
    }, { status: 201 })
  }),

  // Error scenarios
  http.get('/api/self-knowledge/notes/error', () => {
    return HttpResponse.error()
  }),

  http.post('/api/self-knowledge/notes/timeout', () => {
    return new Promise(() => {}) // Never resolves (timeout)
  })
]
```

### EstratÃ©gia de MigraÃ§Ã£o TDD
1. **ğŸ”´ Testes de backup** â†’ **ğŸŸ¢ Backup automÃ¡tico** â†’ **ğŸ”µ RefatoraÃ§Ã£o**
2. **ğŸ”´ Testes migraÃ§Ã£o gradual** â†’ **ğŸŸ¢ ImplementaÃ§Ã£o por etapas** â†’ **ğŸ”µ OtimizaÃ§Ã£o**
3. **ğŸ”´ Testes modo hÃ­brido** â†’ **ğŸŸ¢ TransiÃ§Ã£o controlada** â†’ **ğŸ”µ Limpeza**
4. **ğŸ”´ Testes rollback** â†’ **ğŸŸ¢ RecuperaÃ§Ã£o automÃ¡tica** â†’ **ğŸ”µ ValidaÃ§Ã£o**

---

## ğŸ”§ PIPELINE CI/CD ESPECÃFICO DO MÃ“DULO

### GitHub Actions Workflow

```yaml
# .github/workflows/autoconhecimento-module.yml
name: Autoconhecimento Module CI/CD

on:
  push:
    paths:
      - 'app/autoconhecimento/**'
      - '__tests__/autoconhecimento/**'
      - 'app/components/autoconhecimento/**'

jobs:
  test-autoconhecimento:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run Autoconhecimento Tests
        run: npm run test -- autoconhecimento --coverage

      - name: Check Coverage Threshold
        run: |
          COVERAGE=$(npm run test:coverage -- --reporter=json | jq '.total.lines.pct')
          if (( $(echo "$COVERAGE < 70" | bc -l) )); then
            echo "Coverage $COVERAGE% below threshold 70%"
            exit 1
          fi

      - name: Performance Tests
        run: npm run test -- autoconhecimento --reporter=verbose
        env:
          VITEST_MAX_DURATION: 100

  integration-autoconhecimento:
    needs: test-autoconhecimento
    runs-on: ubuntu-latest
    steps:
      - name: Integration Tests
        run: npm run test:integration -- autoconhecimento

      - name: API Contract Tests
        run: npm run test:contract -- autoconhecimento

  quality-gates:
    needs: [test-autoconhecimento, integration-autoconhecimento]
    runs-on: ubuntu-latest
    steps:
      - name: Quality Gate Check
        run: |
          echo "âœ… Unit Tests: Passed"
          echo "âœ… Integration Tests: Passed"
          echo "âœ… Coverage > 70%: Passed"
          echo "âœ… Performance < 100ms: Passed"
          echo "ğŸ¯ Autoconhecimento Module: READY FOR DEPLOYMENT"
```

---

## ğŸ“Š MÃ‰TRICAS DE SUCESSO TDD

### Indicadores TÃ©cnicos (Baseados na FASE 0)

| MÃ©trica | Target FASE 0 | Target Autoconhecimento | Status |
|---------|---------------|------------------------|--------|
| **Coverage Lines** | 70% | 75% | ğŸ¯ |
| **Coverage Functions** | 70% | 75% | ğŸ¯ |
| **Test Performance** | < 100ms | < 80ms | ğŸ¯ |
| **Suite Completa** | < 30s | < 10s | ğŸ¯ |
| **Zero Bugs CrÃ­ticos** | âœ… | âœ… | ğŸ¯ |

### Indicadores de Qualidade TDD

| Fase | Red Tests | Green Implementation | Blue Refactor | Quality Gate |
|------|-----------|---------------------|---------------|--------------|
| **PreparaÃ§Ã£o** | 12 testes | 12 implementaÃ§Ãµes | 3 refatoraÃ§Ãµes | Coverage > 70% |
| **APIs Core** | 20 testes | 20 implementaÃ§Ãµes | 4 refatoraÃ§Ãµes | Coverage > 75% |
| **Frontend** | 25 testes | 25 implementaÃ§Ãµes | 5 refatoraÃ§Ãµes | Coverage > 80% |
| **MigraÃ§Ã£o** | 8 testes | 8 implementaÃ§Ãµes | 2 refatoraÃ§Ãµes | 100% dados |
| **OtimizaÃ§Ã£o** | 10 testes | 10 implementaÃ§Ãµes | 6 refatoraÃ§Ãµes | Coverage > 85% |

---

## â° CRONOGRAMA DETALHADO TDD

### Semana 1-2: PreparaÃ§Ã£o e Setup TDD
- **Dias 1-3**: Configurar factories especÃ­ficas do mÃ³dulo
- **Dias 4-7**: Criar MSW handlers para todas as APIs
- **Dias 8-10**: Implementar templates de teste base
- **Quality Gate**: 100% setup funcional + 6 testes de verificaÃ§Ã£o passando

### Semana 3-4: APIs Core (TDD Rigoroso)
- **Dias 11-14**: ğŸ”´ Testes self-knowledge notes â†’ ğŸŸ¢ ImplementaÃ§Ã£o â†’ ğŸ”µ RefatoraÃ§Ã£o
- **Dias 15-18**: ğŸ”´ Testes sistema tags â†’ ğŸŸ¢ ImplementaÃ§Ã£o â†’ ğŸ”µ RefatoraÃ§Ã£o
- **Dias 19-21**: ğŸ”´ Testes preferÃªncias â†’ ğŸŸ¢ ImplementaÃ§Ã£o â†’ ğŸ”µ RefatoraÃ§Ã£o
- **Quality Gate**: Coverage > 75% + Performance < 100ms

### Semana 5-6: Frontend Migration (TDD)
- **Dias 22-25**: ğŸ”´ Testes componentes â†’ ğŸŸ¢ MigraÃ§Ã£o â†’ ğŸ”µ RefatoraÃ§Ã£o
- **Dias 26-28**: ğŸ”´ Testes hooks â†’ ğŸŸ¢ ImplementaÃ§Ã£o â†’ ğŸ”µ RefatoraÃ§Ã£o
- **Dias 29-31**: ğŸ”´ Testes integraÃ§Ã£o â†’ ğŸŸ¢ E2E â†’ ğŸ”µ OtimizaÃ§Ã£o
- **Quality Gate**: Coverage > 80% + Zero bugs crÃ­ticos

### Semana 7-8: MigraÃ§Ã£o de Dados e FinalizaÃ§Ã£o
- **Dias 32-35**: ğŸ”´ Testes migraÃ§Ã£o â†’ ğŸŸ¢ Script â†’ ğŸ”µ ValidaÃ§Ã£o
- **Dias 36-38**: ğŸ”´ Testes rollback â†’ ğŸŸ¢ ImplementaÃ§Ã£o â†’ ğŸ”µ DocumentaÃ§Ã£o
- **Dias 39-42**: OtimizaÃ§Ãµes finais e documentaÃ§Ã£o
- **Quality Gate**: 100% dados migrados + Coverage > 85%

---

**ğŸ“… Cronograma Total Estimado**: 6-8 semanas (incluindo TDD rigoroso)
**ğŸ”§ EsforÃ§o TÃ©cnico**: Alto (devido ao TDD, mas com ROI comprovado)
**âš ï¸ Risco**: Baixo (infraestrutura FASE 0 + testes abrangentes)
**ğŸ‘¥ Recursos**: 1 desenvolvedor full-stack + infraestrutura TDD pronta

---

## âœ… CHECKLIST DE VALIDAÃ‡ÃƒO FINAL

### PreparaÃ§Ã£o TDD (FASE 0 Integrada)
- [ ] âœ… Infraestrutura Vitest + RTL + MSW configurada
- [ ] âœ… Factories especÃ­ficas do mÃ³dulo criadas
- [ ] âœ… MSW handlers para todas as APIs implementados
- [ ] âœ… Templates de teste documentados
- [ ] âœ… Pipeline CI/CD especÃ­fico configurado

### Quality Gates por Fase
- [ ] âœ… **PreparaÃ§Ã£o**: Coverage > 70% + Setup 100% funcional
- [ ] âœ… **APIs Core**: Coverage > 75% + Performance < 100ms
- [ ] âœ… **Frontend**: Coverage > 80% + Zero bugs crÃ­ticos
- [ ] âœ… **MigraÃ§Ã£o**: 100% dados migrados + Rollback testado
- [ ] âœ… **FinalizaÃ§Ã£o**: Coverage > 85% + DocumentaÃ§Ã£o completa

---

**ğŸ† STATUS**: âœ… **PLANO REFATORADO COMPLETO - PRONTO PARA EXECUÃ‡ÃƒO**

*Este plano refatorado integra completamente a metodologia e infraestrutura TDD estabelecida na FASE 0, garantindo uma migraÃ§Ã£o segura, testada e de alta qualidade para o mÃ³dulo de autoconhecimento, servindo como modelo para todos os demais mÃ³dulos do StayFocus.*